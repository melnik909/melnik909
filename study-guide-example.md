# Для чего используют `aria-hidden`? Как его лучше использовать?
Влад, привет. 

Перед тобой гайд про атрибут `aria-hidden`. В нем есть практические кейсами, советы и нюансы, которые трубется знать. Мы разберем с тобой следующие вопросы: 
- Для чего используют атрибут?
- В каких практических задачах он полезен?

Гайд составлен с учетом твоих текущих знаний и умений. Как я понял из личного общения у тебя есть опыт верстки, и ты стараешься использовать элементы семантически верно. Это хороший шаг к улучшению цифровой доступности. Также ты можешь протестировать интерфейс при помощи скринридера. При написании гайда я все это учел. 

Надеюсь тебе будет интересно. А теперь поехали!

## Что это такое?
О проблеме доступности цифровых интерфейсов задумались относительно недавно. Лично я изучаю ее с 2016 года. А интерфейсы же проектировали еще в 2000ых годах. По этой причине подавляющее большинство, если не все, спроектированы для людей, видящих их. Графические элементы, механики взаимодействия, элементы управления, все заточено под человека, который может увидеть их. 

Небольшая, но значимая, часть этого опыта в принципе не может подходить для пользователя скринридера. Тут возникает потребность скрыть то, что бесполезно, и заменить полезным и удобным. Здесь вотчина атрибута `aria-hidden`. 

Он полностью скрывает элемент от скринридера, чем-то напоминая этим атрибут `hidden`. Только есть разница. Когда элемент скрывается при помощи атрибута `hidden`, он не доступен скринридерам и его нельзя увидеть. При использовании атрибута `aria-hidden` он продолжает отображаться визуально. 

Для скрытия элемента нужно использовать значение `true`, добавив атрибут с ним к элементу. Например, я сделал это для элемента `<span>`. 
```html
<body>
  <span aria-hidden="true">Этот текст не доступен для скринридера. Он не будет озвучен</span>
</body>
```
Теперь о тексте в элементе `<span>` знают только зрячие пользователи. Скринридером его прочитать нельзя. Где это будет полезно, мы рассмотрим далее. 

## Используем на практике
Перед тем, как я поделюсь ситуациями, где полезно скрытие элементов, у меня есть важное сообщение. **Наша задача заключается в предоставлении равного доступа к возможностям интерфейса как для зрячего человека, так для пользователя скринридера**. Если скрываем элемент, то наша обязанность убедиться в том, что это не ограничивает пользователя. Все должны получить одинаково хороший опыт от взаимодействия с интерфейсом. А теперь к практике.

Сегодня у интерфейсов есть достаточно много декоративных элементов. Большинство из них только мешает пользователям скринридера. Поэтому их скрывают. 

Звучит вроде просто, но все не так однозначно. Для примера я взял заголовок видео одного популярного Youtube канала.
```html
<body>
  <span>Дзюба х Слуцкий х Роман Евгеньев</span>
</body>
```
Есть предположения, где здесь скрыта сложность? Буква "х". Авторы видео используют ее в качестве декоративного разделителя. Для зрячего пользователя в этом нет проблем. Он пропустит символ и прочитает "Дзюба", "Слуцкий" и "Роман Евгеньев". Пользователи скринридеров не могут так. Они услышат текст полностью: "Дзюба ха Слуцкий ха Роман Евгеньев". Вот и думай причем тут "ха".   

Исправить эту проблему просто. Нужно предоставить пользователям скринридеров такой же текст, какой видят зрячие. Они должны услышать: "Дзюба Слуцкий Роман Евгеньев". Для достижения этой цели скроем декоративные разделители с помощью `aria-hidden="true"`. 
```html
<body>
  <span>Дзюба <span aria-hidden="true">х</span> Слуцкий <span aria-hidden="true">х</span> Роман Евгеньев</span>
</body>
```    
Следующим примером полезного использования атрибута `aria-hidden` будут SVG иконки внутри интрактивных элементов. Часто внутри элемента `<svg>` могут быть элементы `<title>`, `<text>`, `<image>` и `<desc>`. Для пример я добавил элемент `<title>` внутрь элемента `<svg>`.
```html
<body>
  <button type="button">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 26 26">
      <title>Стрелка</title>
      <polyline stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" points="19 11 13 5 7 11"></polyline>
      <path d="M13 5 L13 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
    <span>Перейти к началу страницы</span>
  </button>
</body>
```
Здесь скринридеры найдут иконку, а еще в придачу текст "Стрелка". Конечно, все расскажут пользователю. И такая же история будет с элементами `<text>`, `<image>` и `<desc>`. 

Чтобы не спамить нашим пользователям лучше скрыть декоративную иконку. Первым, что можно сделать, это удалить элемент `<title>`.
```html
<body>
  <button type="button">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 26 26">
      <polyline stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" points="19 11 13 5 7 11"></polyline>
      <path d="M13 5 L13 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
    <span>Перейти к началу страницы</span>
  </button>
</body>
```
Это поможет. Но часто бывает так, что в будущем элемент снова добавляют. Поэтому надежнее скрыть железобетонно. Конечно, сделает это атрибут `aria-hidden`. Его нужно добавить к элементу `<svg>`.
```html
<body>
  <button type="button">
    <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 26 26">
      <polyline stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" points="19 11 13 5 7 11"></polyline>
      <path d="M13 5 L13 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
    <span>Перейти к началу страницы</span>
  </button>
</body>
```
Третим примером полезного применения атрибудет создание CSS анимации. Бывает так, что в ней используется текст. Такой случай был у меня. Мне нужно было создать анимацию для лоадера, в котором анимировалось слово "Loading". Разметка была такой:
```html
<body>
  <span class="cp-preloader" data-text="Loading...">Loading...</span>
</body>
```
Для создания эффекта я использовал свойство `content`. В нем я дублировал текст, чтобы он эффектно появлялся. 
```css
.cp-preloader {
  position: relative;
  color: rgba(0, 0, 0, 0.2);
}

.cp-preloader::before {
  content: attr(data-text);
  color: #222;
  position: absolute;
  inset: 0;
}

@media (prefers-reduced-motion: no-preference) {

  .cp-preloader::before {
    animation: cp-preloader34 6s ease-in-out infinite both;
  }

  @keyframes cp-preloader34 {
    0%, 10%, 90%, 100% {
      clip-path: circle(0 at 50% 50%);
    }
    40%, 60% {
      clip-path: circle(50vmax at 50% 50%);
    }
  }
}
```

Тогда я не знал, что скринридеры озвучивают текст из свойства `content`... Они дважды говорили "Loading". 

Я начал думать, как исправить. Ответ очевиден. Нужно вставить текст в HTML и сделать его недоступным для скринридеров. Задачка для атрибута `aria-hidden`.
```html
<body>
  <span class="cp-preloader">
    <span class="cp-preloader__text" aria-hidden="true">Loading...</span>
    Loading...
  </span>
</body>
```
```css
.cp-preloader {
  position: relative;
  color: rgba(0, 0, 0, 0.2);
}

.cp-preloader__text {
  color: #222;
  position: absolute;
  inset: 0;
}

@media (prefers-reduced-motion: no-preference) {

  .cp-preloader__text {
    animation: cp-preloader34 6s ease-in-out infinite both;
  }

  @keyframes cp-preloader34 {
    0%, 10%, 90%, 100% {
      clip-path: circle(0 at 50% 50%);
    }
    40%, 60% {
      clip-path: circle(50vmax at 50% 50%);
    }
  }
}
```
Так я сохранил анимацию и не навредил пользователям скринридера.

## Особенности использования
Мы уже рассмотрели значение `true`, кроме него есть еще два: `false` и `undefined`. Рассмотрим все их более подробно. У них куча нюансов! 

Начнем с того, что добавим для элемента `<span>` только сам атрибут `aria-hidden`.
```html
<body>
  <span aria-hidden>Этот текст доступен для скринридера? Не факт</span>
</body>
```
В этом случае браузер вместе со скринридером понимают значение атрибута, как `undefined`. Итоговое решение о доступности элемента будет определено, опираясь на его стили. В теории должно было все хорошо. А на практике получается не очень. 

Я провел тест в скринридере NVDA и JAWS в трех браузерах. Google Chrome, Firefox и Edge. Результаты противоположны полностью. В NVDA я смог попасть на элемент, но текст озвучен не был. В JAWS во всех браузерах текст озвучивается. Такие дела. 

Единственное, что стабильно, это несколько случаев, когда текст точно не будет доступен. Первый, это использование CSS свойства `display` со значением `none`. 
```html
<body>
  <span aria-hidden class="non-accessible-text">Этот текст не доступен для скринридера. Он не будет озвучен</span>
</body>
```
```css
.non-accessible-text {
  display: none;
}
```
Второй случай является следствием первого. Атрибут `hidden` устанавливает `display: none` для элемента.
```html
<body>
  <span aria-hidden hidden>Этот текст не доступен для скринридера. Он не будет озвучен</span>
</body>
```
Третий, это CSS свойство `visibility` со значением `hidden`. 
```html
<body>
  <span aria-hidden class="non-accessible-text">Этот текст не доступен для скринридера. Он не будет озвучен</span>
</body>
```
```css
.non-accessible-text {
  visibility: hidden;
}
```
Значение `false`. Оно сообщает, что элемент доступен для скринридера. На практике он пригодится очень редко. Лично я ни разу его не использовал. Нет смысла делать то, что уже сделано без моего участия. 

Дополнительно в интернете много сообщений о том, что значение работает нестабильно в разных браузерах. Так что, как мне кажется, лучше про него забыть. 

И наконец значение `true`. Да, оно полностью скрывает элемент вместе с дочерними элементами, если они есть.
```html
<body>
  <span aria-hidden="true">Этот текст не доступен для скринридера. Он не будет озвучен</span>

  <div aria-hidden="true">
    <span>Родительский элемент и этот текст тоже не доступны для скринридера</span>
  </div>
</body>
```
Правда здесь нас ждет подвох.  К сожалению, `aria-hidden="true"` сработает не для каждого элемента. Для интерактивных есть особенности. Попробуем добавить атрибут для элемента `<button>`.
```html
<body>
  <!-- Элемент button будет скрыт не всегда -->
  <button aria-hidden="true" type="button">Перейти</button>
</body>
```
Если пользователь скринридера переключился на элемент `<button>` при помощи клавиш стрелок (`↑` или `↓`), то он будет недоступен. Но! Если это произойдет при помощи клавиши `Tab`, то кнопка станет доступной. Тут начинается полная вакханалия.

Скринридеры ведут себя по разному. JAWS в Google Chrome, Firefox и Edge будет озвучивать либо предыдущий, либо следующий элемент. Я не понял, от чего это зависит. NVDA в тех же браузерах скажет "Пусто". VoiceOver в Google Chrome и Safari вообще произнесут текст кнопки, как будто ее не скрывали. А в Firefox она будет скрыта. В общем полный капут.

Такие же проблемы нас ждут, если добавить `aria-hidden="true"` к родительскому элементу, который содержит интерактивный элемент.
```html
<body>
  <!-- Элемент button будет скрыт не всегда -->
  <div class="parent" aria-hidden="true">
    <button type="button">Перейти</button>
  </div>
</body>
```
По этой причине строго нельзя использовать `aria-hidden="true"` для элементов, содержащие интерактивные элементы.

На такое поведение скринридеров может повлиять атрибут `tabindex`. Он может отключить интерактивность у элемента, и тогда он становится полностью недоступным. Для этого надо использовать значение `-1`.
```html
<body>
  <!-- Элемент button будет скрыт всегда -->
  <button aria-hidden="true" tabindex="-1" type="button">Перейти</button>
</body>
```
Все скринридеры скроют кнопку. Только не будем спешить радоваться. Я говорил, что большинство интерфейсов разработаны для пользователя с мышкой. Есть функции, который нужны ему, но полностью бесполезны для пользователей клавиатуры или скринридера. Здесь трюк с `aria-hidden="true" tabindex="-1"` будет полезен. Но это всё равно хак! 

Самый лучший вариант переработать интерфейс так, чтобы были общие паттерны взаимодействия. Да, это дополнительная работа всей команды, но в этом случае результат будет лучше для пользователей. 

## Заключение
Подведём итог. Ключевые моменты при работе с атрибутом `aria-hidden`:
- Он отлично подходит для скрытия визуальных декоративных элементов, бесполезных для пользователя скринридера;
- Использовать атрибут нужно так, чтобы не ухудшить опыт пользователя скринридера;
- Есть особенности использования атрибута, о которых надо помнить;
- Лучше не скрывать интерактивные элементы, а разрабатывать новые паттерны взаимодействия всей командой.

В целом с атрибутом нужно быть аккуратном, но его не стоит бояться. Если ты сохранишь равный по возможностям пользовательский опыт, то все будет хорошо.

На этом все. Желаю успехов!
